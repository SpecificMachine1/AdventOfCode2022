;;; https://adventofcode.com/2022/day/9
(define-library (ports 9)
  (import (scheme base)
          (aoc file)
          (srfi 69))
  (export get-data run-motions positions-visited run-motions*)
(begin

(define-record-type <knot>
  (knot name current-pos history visited)
  knot?
  (name knot-get-name)
  (current-pos knot-get-current-pos knot-set-current-pos!)
  (history knot-get-history knot-set-history!)
  (visited knot-get-visited knot-set-visited!))

(define (make-knot name start-pos)
  (knot name start-pos (list start-pos) (alist->hash-table (list (cons start-pos 1)) equal?)))

(define (update-knot-pos knot pos)
  (knot-set-current-pos! knot pos)
  (knot-set-history! knot (cons pos (knot-get-history knot)))
  (hash-table-set! (knot-get-visited knot)
                   pos
                   (+ 1 (hash-table-ref/default (knot-get-visited knot) pos 0))))
  
(define (get-data filename)
  (let ((tokens (reverse (get-line-tokens filename))))
    (map (lambda (pair) (list (car pair) (string->number (cadr pair)))) tokens)))

(define (run-motions motions)
  (let ((head-motion-alist (list (cons "R" (lambda (x y) (list (+ x 1) y)))
                            (cons "L" (lambda (x y) (list (- x 1) y)))
                            (cons "U" (lambda (x y) (list x (+ y 1))))
                            (cons "D" (lambda (x y) (list x (- y 1))))))
        (head (make-knot 'head (list 0 0)))
        (tail (make-knot 'tail (list 0 0))))
    (define (head-update update-fun)
      (let* ((pos (knot-get-current-pos head))
             (x (car pos))
             (y (cadr pos)))
        (update-knot-pos head (update-fun x y))))
    (define (tail-update)
      (let* ((head-pos (knot-get-current-pos head))
             (tail-pos (knot-get-current-pos tail))
             (head-x (car head-pos))
             (head-y (cadr head-pos))
             (tail-x (car tail-pos))
             (tail-y (cadr tail-pos))
             (dx (- head-x tail-x))
             (dy (- head-y tail-y)))
        (cond
          ((and (<= -1 dx 1)
                (<= -1 dy 1)))
          ((zero? dx) (update-knot-pos tail (list tail-x (+ (/ (abs dy) dy) tail-y))))
          ((zero? dy) (update-knot-pos tail (list (+ (/ (abs dx) dx) tail-x) tail-y)))
          (else (update-knot-pos tail (list (+ (/ (abs dx) dx) tail-x)
                                            (+ (/ (abs dy) dy) tail-y)))))))
    (let motions-loop ((rest motions))
      (cond
        ((null? rest) tail)
        (else (let* ((this (car rest))
                     (move-head (cdr (assoc (car this) head-motion-alist))))
                (let motion-loop ((moves (cadr this)))
                  (cond
                    ((zero? moves) (motions-loop (cdr rest)))
                    (else (head-update move-head)
                          (tail-update)
                          (motion-loop (- moves 1)))))))))))

(define (run-motions* motions n)
  (let* ((head-motion-alist (list (cons "R" (lambda (x y) (list (+ x 1) y)))
                            (cons "L" (lambda (x y) (list (- x 1) y)))
                            (cons "U" (lambda (x y) (list x (+ y 1))))
                            (cons "D" (lambda (x y) (list x (- y 1))))))
        (i -1)
        (incr (lambda () (set! i (+ 1 i)) i))
        (knots (list->vector (map (lambda (_) (make-knot (incr) (list 0 0))) (make-list n))))
        (head (vector-ref knots 0))
        (tail (vector-ref knots (- n 1))))
    (define (head-update update-fun)
      (let* ((pos (knot-get-current-pos head))
             (x (car pos))
             (y (cadr pos)))
        (update-knot-pos head (update-fun x y))))
    (define (rest-update head tail)
      (let* ((head-pos (knot-get-current-pos head))
             (tail-pos (knot-get-current-pos tail))
             (head-x (car head-pos))
             (head-y (cadr head-pos))
             (tail-x (car tail-pos))
             (tail-y (cadr tail-pos))
             (dx (- head-x tail-x))
             (dy (- head-y tail-y)))
        (cond
          ((and (<= -1 dx 1)
                (<= -1 dy 1)))
          ((zero? dx) (update-knot-pos tail (list tail-x (+ (/ (abs dy) dy) tail-y))))
          ((zero? dy) (update-knot-pos tail (list (+ (/ (abs dx) dx) tail-x) tail-y)))
          (else (update-knot-pos tail (list (+ (/ (abs dx) dx) tail-x)
                                            (+ (/ (abs dy) dy) tail-y)))))))
    (let motions-loop ((rest motions))
      (cond
        ((null? rest) tail)
        (else (let* ((this (car rest))
                     (move-head (cdr (assoc (car this) head-motion-alist))))
                (let motion-loop ((moves (cadr this)))
                  (cond
                    ((zero? moves) (motions-loop (cdr rest)))
                    (else (head-update move-head)
                          (let tail-loop ((lead-index 0) (follow-index 1))
                            (cond
                              ((= n follow-index) (motion-loop (- moves 1)))
                              (else (rest-update (vector-ref knots lead-index) (vector-ref knots follow-index))
                                    (tail-loop (+ lead-index 1) (+ follow-index 1))))))))))))))
(define (positions-visited knot)
  (hash-table-size (knot-get-visited knot)))
))
