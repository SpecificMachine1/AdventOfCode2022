(define-library (day 11)
  (import (scheme base)
          (scheme cxr)
          (scheme eval)
          (scheme write)
          (srfi 1)
          (aoc file)
          (aoc string))
  (export get-data monkey-get-items monkey-get-inspects one-round n-rounds monkey-business n-rounds-2)
(begin

(define-record-type <monkey>
  (monkey num items operation test if-true if-false inspects divisor)
  monkey?
  (num monkey-get-num)
  (items monkey-get-items monkey-set-items!)
  (operation monkey-get-operation)
  (test monkey-get-test)
  (if-true monkey-get-if-true)
  (if-false monkey-get-if-false)
  (inspects monkey-get-inspects monkey-set-inspects!)
  (divisor monkey-get-divisor))

(define (inspect! monkey)
  (let ((items (monkey-get-items monkey)))
    (monkey-set-inspects! monkey (+ (monkey-get-inspects monkey) (length items)))
    (monkey-set-items! monkey '())
    items))

(define (throw-to! monkey item)
  (monkey-set-items! monkey (append (monkey-get-items monkey) (list item))))

(define (get-data filename)
  (let ((data (get-line-tokens filename)))
    (define (chunk-data data)
      (define description 6)
      (define description+gap 7)
      (let chunk-loop ((token-list data) (acc '()))
        (cond
          ((null? (drop token-list description)) (cons (take token-list description) acc))
          (else (chunk-loop (drop token-list description+gap) (cons (take token-list description) acc))))))
    (define (handle-chunk chunk)
      (define uninspected 0)
      (monkey (handle-monkey-tokens (sixth chunk))
              (handle-items-tokens (fifth chunk))
              (handle-operation-tokens (fourth chunk))
              (handle-test-tokens (third chunk))
              (handle-if-tokens (second chunk))
              (handle-if-tokens (first chunk))
              uninspected
              (handle-divisor (third chunk))))
    (define (handle-monkey-tokens tokens)
      (stripped-string->number (second tokens)))
    (define (handle-items-tokens tokens)
      (map stripped-string->number (cddr tokens)))
    (define (handle-operation-tokens tokens)
      (let-values (((a op b) (apply values  (map string->math (cdddr tokens)))))
        (if (and (member op '(+ - / *)) (or (eq? a 'old) (number? a)) (or (eq? b 'old) (number? b))) 
          (eval `(lambda (old) (,op ,a ,b)) (environment '(scheme base))) ; I tried with syntax-rules
          (error "unsanitary op tokens"))))
    (define (handle-test-tokens tokens)
      (let ((divisor (handle-divisor tokens)))
        (lambda (n) (zero? (remainder n divisor)))))
    (define (handle-if-tokens tokens)
      (string->number (sixth tokens)))
    (define (handle-divisor tokens)
      (string->number (fourth tokens)))
    (list->vector (map handle-chunk (chunk-data data))))) 

(define (one-round monkeys factor)
  (let ((len (vector-length monkeys)))
    (let monkey-loop ((n 0))
      (if (= len n)
        monkeys
        (let ((this (vector-ref monkeys n)))
          (let item-loop ((items (inspect! this)))
            (if (null? items)
              (monkey-loop (+ n 1))
              (let* ((worry (quotient ((monkey-get-operation this) (car items)) factor)))
                (if ((monkey-get-test this) worry)
                  (throw-to! (vector-ref monkeys (monkey-get-if-true this)) worry)
                  (throw-to! (vector-ref monkeys (monkey-get-if-false this)) worry))
                (item-loop (cdr items))))))))))

(define (n-rounds monkeys n factor)
  (for-each (lambda (i) (one-round monkeys factor)) (iota n))
  monkeys)

(define (monkey-business monkeys)
  (apply * (fold (lambda (n acc)
                   (cond
                     ((> n (apply min acc)) (list n (apply max acc)))
                     (else acc)))
                 (list 0 0)
                 (map monkey-get-inspects (vector->list monkeys)))))

(define (get-big-factor monkeys)
  (apply * (map monkey-get-divisor (vector->list monkeys))))

(define (n-rounds-2 monkeys n)
  (let ((factor (get-big-factor monkeys)))
    (for-each (lambda (i) (one-round-2 monkeys factor)) (iota n))
    monkeys))
(define (one-round-2 monkeys factor)
  (let ((len (vector-length monkeys)))
    (let monkey-loop ((n 0))
      (if (= len n)
        monkeys
        (let ((this (vector-ref monkeys n)))
          (let item-loop ((items (inspect! this)))
            (if (null? items)
              (monkey-loop (+ n 1))
              ;; taking the worry value modulo the product of all the primes in the tests keeps the
              ;; results the same without integer overflow
              (let* ((worry (remainder ((monkey-get-operation this) (car items)) factor)))
                (if ((monkey-get-test this) worry)
                  (throw-to! (vector-ref monkeys (monkey-get-if-true this)) worry)
                  (throw-to! (vector-ref monkeys (monkey-get-if-false this)) worry))
                (item-loop (cdr items))))))))))
))
